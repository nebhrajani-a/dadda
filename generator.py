import numpy as np
from sys import argv
from typing import TextIO
from datetime import datetime
from pytz import timezone
from uuid import uuid4
from re import sub


class DaddaMatrix:
    def __init__(self, num_bits: int, verilog_module_name: str = "dadda_multiplier"):
        # Initialize attributes.
        self.num_bits = num_bits
        self.verilog_module_name = verilog_module_name
        self.__handle = open(verilog_module_name + ".v", "w")
        self.mult_state_to_verilog = {}
        self.mult_state = np.zeros((3 * num_bits // 2, 2 * num_bits - 1), dtype="int")

        # Write out Verilog header.
        verilog_hdr = f"""\
/**********************************************************************************
  Autogenerated by DaddaMatrix (generator.py) on {datetime.now(timezone('America/Chicago')).isoformat()}
**********************************************************************************/
module {verilog_module_name} (
  input  wire [{num_bits-1}:0] a,
  input  wire [{num_bits-1}:0] b,
  output wire [{2*num_bits-1}:0] product
);\n\n"""
        self.__handle.write(verilog_hdr)

        # Generate maximum-height (d) sequence for stages.
        self.d_seq = [0, 2]
        while self.d_seq[-1] <= num_bits:
            self.d_seq.append(3 * self.d_seq[-1] // 2)
        for j, d in reversed(list(enumerate(self.d_seq))):
            if d < num_bits:
                self.d_idx = j
                break

    def __generate_verilog_identifier(self):
        generated_uuid = str(uuid4())
        verilog_identifier = sub("[^a-zA-Z0-9_]", "_", generated_uuid)
        if not verilog_identifier[0].isalpha():
            verilog_identifier = "v_" + verilog_identifier
        verilog_identifier = verilog_identifier[:1024]
        self.__handle.write(f"  wire   {verilog_identifier};\n")
        return verilog_identifier

    def __print_delimiter(self):
        self.__handle.write("\n  /*" + "=" * 80 + "*/\n\n")

    def __assert_mappings(self):
        for (i, j), value in np.ndenumerate(self.mult_state):
            if value:
                assert (i, j) in self.mult_state_to_verilog
        assert np.count_nonzero(self.mult_state) == len(self.mult_state_to_verilog)

    def partial_products(self):
        # Generate the initial partial product pyramid and Verilog nets.
        row_idxs = [0 for _ in range(2 * self.num_bits - 1)]
        for i in range(self.num_bits):
            for j in range(self.num_bits):
                net_name = self.__generate_verilog_identifier()
                self.mult_state[row_idxs[i + j]][i + j] = 1
                self.mult_state_to_verilog[(row_idxs[i + j], i + j)] = net_name
                self.__handle.write(f"  assign {net_name} = a[{i}] & b[{j}];\n")
                row_idxs[i + j] += 1
        self.__assert_mappings()
        self.__print_delimiter()

        # print(self.mult_state)

    def __find_last_idx(self, col: np.array) -> int:
        return col.tolist().index(0)

    def __reduce_column(self, t, j):
        while True:
            row_height = np.sum(t[j])

            if row_height <= self.d_seq[self.d_idx]:
                return

            if row_height == self.d_seq[self.d_idx] + 1:
                # Generate a half adder
                sum_net = self.__generate_verilog_identifier()
                carry_net = self.__generate_verilog_identifier()
                op0 = self.mult_state_to_verilog[(0, j)]
                op1 = self.mult_state_to_verilog[(1, j)]

                self.__handle.write(
                    f"  assign {{{carry_net}, {sum_net}}} = {op0} + {op1};\n"
                )

                # Place it into the matrix.
                bot_verilog_nets = []
                last_idx = self.__find_last_idx(t[j])
                for i in range(2, last_idx):
                    bot_verilog_nets.append(self.mult_state_to_verilog[(i, j)])
                    del self.mult_state_to_verilog[(i, j)]

                for i, net in enumerate(bot_verilog_nets):
                    self.mult_state_to_verilog[(i, j)] = net

                self.mult_state_to_verilog[(last_idx - 2, j)] = sum_net

                self.mult_state_to_verilog[
                    (self.__find_last_idx(t[j + 1]), j + 1)
                ] = carry_net

                # Two operations on mult_state:
                # a) Truncate the current column to d_seq[d_idx] bits
                t[j][self.__find_last_idx(t[j]) - 1] = 0
                # b) Carry-out to the end of the next column.
                t[j + 1][self.__find_last_idx(t[j + 1])] = 1
                return

            sum_net = self.__generate_verilog_identifier()
            carry_net = self.__generate_verilog_identifier()
            op0 = self.mult_state_to_verilog[(0, j)]
            op1 = self.mult_state_to_verilog[(1, j)]
            op2 = self.mult_state_to_verilog[(2, j)]

            self.__handle.write(
                f"  assign {{{carry_net}, {sum_net}}} = {op0} + {op1} + {op2};\n"
            )

            bot_verilog_nets = []
            last_idx = self.__find_last_idx(t[j])
            for i in range(3, last_idx):
                bot_verilog_nets.append(self.mult_state_to_verilog[(i, j)])
                del self.mult_state_to_verilog[(i, j)]

            for i, net in enumerate(bot_verilog_nets):
                self.mult_state_to_verilog[(i, j)] = net

            self.mult_state_to_verilog[(last_idx - 3, j)] = sum_net

            for i in range(last_idx - 2, t.shape[0]):
                if (i, j) in self.mult_state_to_verilog:
                    del self.mult_state_to_verilog[(i, j)]

            self.mult_state_to_verilog[
                (self.__find_last_idx(t[j + 1]), j + 1)
            ] = carry_net

            # Two operations on mult_state:
            # a) Chop two bits off the bottom of the current column.
            t[j][self.__find_last_idx(t[j]) - 1] = 0
            t[j][self.__find_last_idx(t[j]) - 1] = 0
            # b) Carry-out to the end of the next column.
            t[j + 1][self.__find_last_idx(t[j + 1])] = 1

    def __reduce_stage(self):
        t = self.mult_state.T
        for j, col in enumerate(t):
            self.__reduce_column(t, j)
        # print(self.mult_state)
        self.__assert_mappings()
        self.__print_delimiter()

    def reduce_stages(self):
        init = self.d_idx
        for i in range(init, 0, -1):
            self.d_idx = i
            self.__reduce_stage()

    def adder(self):
        ops = [[] for _ in range(2)]
        for i, row in enumerate(self.mult_state[:2]):
            for j, col in enumerate(row):
                if col:
                    ops[i].insert(0, self.mult_state_to_verilog[(i, j)])
                else:
                    ops[i].insert(0, "1'b0")

        assert len(ops[0]) == len(ops[1])
        concat = ["{" + ", ".join(x for x in op) + "}" for op in ops]
        self.__handle.write(f"  assign product = {concat[0]} + {concat[1]};\n")
        self.__print_delimiter()

    def __del__(self):
        self.__handle.write("\nendmodule\n")
        self.__handle.close()


# Make CLI, then make Makefile to link Python to an iVerilog TB
if __name__ == "__main__":
    if __debug__:
        np.set_printoptions(threshold=np.inf)
        np.set_printoptions(linewidth=np.inf)

    dm = DaddaMatrix(int(argv[1]))
    dm.partial_products()
    dm.reduce_stages()
    dm.adder()
    print(f"Generated {dm.num_bits} bit Dadda multiplier in file {dm.verilog_module_name}.v")
